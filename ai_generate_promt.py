import os
import sys
import json
import time
import requests
import argparse # Used for robust argument parsing

def get_gemini_api_key():
    """Retrieves the Gemini API key from environment variables."""
    return os.environ.get('GEMINI_API_KEY', '')

def generate_content(prompt, api_key):
    """Calls the Gemini API to generate text content."""
    # Using gemini-2.5-flash for its speed and capability in code generation
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key={api_key}"
    headers = {
        'Content-Type': 'application/json',
    }
    payload = {
        'contents': [
            {
                'parts': [
                    {'text': prompt}
                ]
            }
        ]
    }
    
    # Use exponential backoff to handle potential rate-limiting.
    for i in range(5):
        try:
            response = requests.post(url, headers=headers, data=json.dumps(payload))
            response.raise_for_status() # Raise an exception for bad status codes (e.g., 400, 500)
            return response.json()
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 429: # Too Many Requests
                sleep_time = 2 ** i # Exponential backoff
                print(f"Rate limit exceeded. Retrying in {sleep_time} seconds...")
                time.sleep(sleep_time)
            else:
                print(f"HTTP Error: {e.response.status_code} - {e.response.text}", file=sys.stderr)
                return None
        except Exception as e:
            print(f"An unexpected error occurred: {e}", file=sys.stderr)
            return None
    return None

def write_to_file(file_path, content):
    """Writes the generated content to a file."""
    try:
        # Use explicit UTF-8 encoding for reliable writing
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"Content successfully written to {file_path}")
    except IOError as e:
        print(f"Error writing to file {file_path}: {e}", file=sys.stderr)

if __name__ == '__main__':
    # --- START: Argument Parsing Correction ---
    # We now expect the prompt to be passed as a file path using --prompt-file
    parser = argparse.ArgumentParser(description="AI prompt generation tool for Jenkins coverage improvement.")
    
    # Required argument for the prompt file path
    parser.add_argument('--prompt-file', required=True, help='Path to the file containing the multi-line prompt content (generated by Jenkins).')
    
    # Positional arguments for context and output files (maintaining original order)
    parser.add_argument('context_file', help='Path to the coverage context file (e.g., build/coverage.info).')
    parser.add_argument('output_file', help='Path to the file where the AI output (test code) will be written.')
    
    args = parser.parse_args()
    
    # --- END: Argument Parsing Correction ---
    
    # --- START: File Reading Correction ---
    try:
        # Read the prompt content from the file path provided by Jenkins.
        # Using 'utf-8' encoding here is key to preventing the decoding errors.
        with open(args.prompt_file, 'r', encoding='utf-8') as f:
            prompt = f.read()

    except FileNotFoundError:
        print(f"Error: Prompt file not found at {args.prompt_file}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading prompt file {args.prompt_file}: {e}", file=sys.stderr)
        sys.exit(1)

    # --- END: File Reading Correction ---

    # log_path and output_path variables renamed for clarity, 
    # but still map to the positional arguments:
    # log_path = args.context_file
    output_path = args.output_file
    
    api_key = get_gemini_api_key()

    if not api_key:
        print("API key not found. Please set the GEMINI_API_KEY environment variable.", file=sys.stderr)
        sys.exit(1)

    # Call the AI to generate content based on the prompt
    response_data = generate_content(prompt, api_key)

    if response_data and 'candidates' in response_data and len(response_data['candidates']) > 0:
        generated_text = response_data['candidates'][0]['content']['parts'][0]['text']
        write_to_file(output_path, generated_text)
    else:
        print("Failed to get a valid response from the Gemini API.", file=sys.stderr)
        # Write an empty string or error message to the output file to prevent
        # the subsequent C++ compilation from failing with junk text.
        write_to_file(output_path, "/* AI generation failed or returned no text. */")
        sys.exit(1)
        